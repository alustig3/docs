# Programming tasks in pyControl

## Overview

Behavioural tasks in pyControl are implemented as state machines, the basic elements of which are states and events.  To implement a task the user creates a state machine description file written in python.  There are example tasks in the command line interface [tasks](https://bitbucket.org/takam/pycontrol/src/default/tasks/?at=default) folder.

Every state machine description file starts by importing some utility functions and constants:

```python
from pyControl.utility import *
```

If you are using a hardware definition file to specify external [hardware](hardware.md) you also need to import the hardware definition:

```python
import hardware_definition as hw
```

### States

The state machine has a set of states defined by the user, and at any point in time it is in one of these states.  The set of states is defined by creating a varible called `states` which is a list of state names:

```python
states = ['state_A', 'state_B']
```

The state the machine starts in must be specified by setting a variable called `initial_state` to the name of the initial state: 

```python
initial_state = 'state_A'
```

### Events

Events cause the state machine to do things, they may be generated externally by hardware inputs or internally by setting timers.  The user specifies the events used by the state machine by creating a variable called `events` which is a list of event names.

```python
events = ['event_A, event_B'] 
```

Events used by internal timers can have whatever name you want.  Events generated by external inputs must have the event name specified for the relevent input in the hardware definition.

### State machine behaviour

The behaviour of the state machine is defined by writing a set of *state behaviour functions*, each of which defines the behaviour of one state.  The name of the function must be the same as the name of the state whose behaviour it defines, and the function must take a single argument called `event`.  When an event occurs the function corresponding to the current state is called with the event that occured as an argument.  For example if `'event_A'` occurs when the state machine is in `'state_A'`, the function `state_A` is called with `'event_A'` as an argument.

```python
def state_A(event):
    if event == 'event_A':
        # do something.
    elif event == 'event_B':
        # do something else.
```

Any valid micropython code can be put in state behaviour functions, though the code should execute fast as it will block any other behaviour of the state machine while it is executing.

### Changing state

The function `goto_state` tells the state machine to transition to the state who's name is provided as an argument.

```python
goto_state('state_B')
```

When a state transition occurs two special events called `'exit'` and `'entry'` are generated.  The `'exit'` event is evaluated in the state that is being exited, while the `'entry'` event is evaluated in the state which is being entered. These events allow code to be exectued every time a state is entered or exited, irrespective of the event that triggered the state transition.  Example usage:


```python
def state_A(event):
    if event == 'entry':
        # Code here executes when state_A is entered.
    elif event == 'exit':
        # Code here executes when state_A is exited.
```

It is recomended not to put any code in a state behaviour function after a `goto_state` because it will be executed following the state transition when the task is in the subsequent state, potentially causing hard to identify bugs.

### Time dependent behaviour.

The simplest way to implement time dependent behaviour is using the `timed_goto_state` function.  This tells the state machine to transition to a specified state after a specified interval has elapsed.

```python
timed_goto_state('state_C', 10*second) # Transition to state 'state_C' after 10 seconds.
```

If a state transition occurs for any reason before the `timed_goto_state` triggers, the  `timed_goto_state` is canceled and will have no effect.

Timers provide a more flexible way of implementing time dependent behaviour by allowing a specified event to be triggered after a specified time has elapsed.

```python
set_timer('event_A', 100 * ms) # Trigger event 'event_A' after 100 ms.
```

Events triggered by timers are not logged in the data output but any state transitions they generate are logged as normal.  Timers generate the specified event regardless of whether the state machine has changed state since the timer was set.  You can set multiple timers for the same event, for example the following code will set two timers, causing *event_C* to occur twice, once after 1 second and once after 3 seconds have elapsed.

```python
set_timer('event_C', 1 * second)
set_timer('event_C', 3 * second)
```

The function `disarm_timer` disarms all active timers which are due to generate the specified event.  

```python
disarm_timer('event_A')
```

The function `reset_timer` disarms all active timers due to generate the specified event and sets a new timer to generate the specified event after the specified duration.

```python
reset_timer('event_A', 50 * minute)
```

The constants `ms`, `second`, `minute`, and `hour` can be used as in the examples above.

You can also get the current time using the `get_current_time` function which returns the number of milliseconds since the framework started running.


```python
x = get_current_time()
```

### Run start and end behaviour

Code can be executed when the framework starts or stops running by defining the following functions in the state machine discription:


```python
def  run_start():
    # Code here is executed when the framework starts running.

def run_end():
    # Code here is executed when the framework stops running.
```

The framework can be stopped from within a state machine by calling the function: 

```python
stop_framework()
```

When the framwork is stopped in this way, the `run_end` function will be called as usual.  The typical use of `stop_framework` is to stop the framework at the end of the behaviour session, dependent on a timer or criterion such as the number of rewards delivered.

### State independent behaviour

To implement behaviour which occurs irrespective of which state the machine is in, the following function can be defined in the state machine description:


```python
def all_states(event):
    # Code here will be executed irrespective of the state the machine is in.
```

After the `all_states` function is executed the state behaviour function for the current state will be executed.  To block execution of the state specific behaviour function make the `all_states` function 
return `True`:


```python
def all_states(event):
    # Code here will be executed irrespective of the state the machine is in 
    if condition:
        return True # If condition is True state specific behaviour will not be executed.
```


### Variables

Variable names should start with `v.` , for example:

```python
v.variable_A = 0.5
```

Variables are referenced in state behaviour functions using the same syntax:

```python
def state_A(event):
    if event == 'event_A':
        if v.variable_A > 0.3:
            # do something
        else:
            # do something else.
```

Starting all variable names with `v.` makes all variables attributes of a single object called `v` (imported from `pyControl.utility`).  This avoids problems that could otherwise occur when variables are accessed or set in state behaviour functions due to these functions having their own [namespaces](https://docs.python.org/3/tutorial/classes.html).  It also allows the GUI and command line interface to access the variables to set or get their values.

### Random numbers and math

Various random number generation and math functions are provided which are detailed in the function reference section below.

### Data output

Whenever an event occurs it is output to the serial line along with a timestamp. Whenever a state transition occurs the state that is entered is output to the serial line with a timestamp.  

The `print()` function has modified behavour when called within the context of a state machine definition file: a timestamp is prefixed to the string provided as an argument before it is printed to the serial line.  The print function can therefore be used to output arbitrary data with timestamps consistent with those of events and state transitions.

## Function reference

### State machine functions

---

**goto_state**

```python
goto_state(next_state)
```

Transition to state `next state`.  An  `'exit'` event is processed in the state that is being left, and an `'entry'` event is processed in the state that is being entered.

*Example usage:*  

```python
goto_state('state_A') # Transition to state 'state_A'
```

---

**timed_goto_state**

```python
timed_goto_state(next_state, interval)
```

Transition to state `next state` after `interval` milliseconds have elapsed.  The current state will behave as normal till the state transition occurs.  `'entry'` and  `'exit'`  actions will be processed when the state transition occurs as with `goto_state`.  If a state transition occurs for any reason before the `timed_goto_state` triggers, the  `timed_goto_state` is canceled and will have no effect.  Constants `ms`, `second`, `minute` and  `hour` can be used in specifying the interval as shown in an example below.

*Example usage:*  

```python
timed_goto_state('state_B', 100*ms)    # Transition to state 'state_B' after 100 ms

timed_goto_state('state_C', 10*second) # Transition to state 'state_C' after 10 seconds.
```

---

**set_timer**

```python
set_timer(event, interval)
```

Set a timer to trigger the specified `event` after `interval` milliseconds have elapsed.  When a timer is set it will trigger the specified event at the specified time irrespective of any state transitions that have occurred after it was set, unless it is disarmed or reset using `disarm_timer` or `reset_timer` (see below).

*Example usage:*  

```python
set_timer('event_X', 5*second) # Trigger event 'event_X' after 5 seconds
```

---

**disarm_timer**

```python
disarm_timer(event)
```

Disarm any active timers due to trigger specified `event`.  The events that would have been generated by the disarmed timers will not be generated.

*Example usage:*  

```python
disarm_timer('event_X') # Disarm all timers set to trigger event 'event_X'
```

---

**reset_timer**

```python
reset_timer(event, interval)
```

Disable any active timers due to trigger specified `event` and set new timer to return specified event after `interval` milliseconds have elapsed.

*Example usage:*  

```python
reset_timer('event_X', 5*minute) # Disable any timers due to trigger event 'event_X' and
                                 # set a timer to trigger 'event_X' in 5 minutes.
```

---

**get_current_time**

```python
get_current_time()
```

Returns the number of milliseconds since the framework started running.

---

**publish_event**

```python
publish_event(event)
```

Trigger the specified event.  The principal use case is to generate an event in the data output to log when something important has happened.  

---

**print**

```python
print(print_string)
```

Print `print_string` to the data output.  Printed strings are given a time-stamp so that the time the print statement was executed is recorded in the data file.

---

**stop_framework**

```python
stop_framework()
```

Stop the framework running.  

---

### Random functions and classes

Functions and classes for random number generation.

---

**random**

```python
random()
```

Return a random float between 0 and 1.

---

**withprob**

```python
withprob(p)
```

Return a random boolean that is True with probability `p`.

---

**shuffled**


```python
shuffled(L)
```

Return a shuffled copy of list `L`.

---

**randint**

```python
randint(a,b)
```

Return a random integer `N` such that `a` <= `N` <= `b`.

---

**sample_without_replacement**

```python
class sample_without_replacement(items)
```

Class for randomly sampling elements from list `items` without replacement.  When all items have been sampled the sampling begins again with the full list.

*Methods:*

`sample_without_replacement.next()`      Get the next sample.

*Example usage:*

```python

x = sample_without_replacement(['a','b','c']) # Instantiate with list ['a','b','c']

next_sample = x.next() # Get the next sample.
```
---

### Math functions and classes.

The micropython [math](https://docs.micropython.org/en/latest/pyboard/library/math.html) module provides many math functions in addition to those below.

---

**mean**

```python
mean(x)
``` 

Return the mean value of x.

---

**exp_mov_ave**

```
class exp_mov_ave(tau, init_value=0)
```

Class for calculating exponential moving average with specified time constant `tau` and intial value `init_value`.

*Methods:*

`exp_mov_ave.update(sample)`    Update the moving average with a new sample.

*Atributes:*

`exp_mov_ave.value`     The current value of the moving average.

*Example usage:*

```python
y = exp_mov_ave(tau=8, init_value=0.5) # Initiaise a moving average object with
                                       # time constant of 8 samples and initial value of 0.5

y.update(sample)  # Update the value of the moving average with a new sample.

current_value = y.value  # Get the current value of the moving average.
```

